// Generates Piece movement.

//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
)

var (
	kingAttackDir      = []Dir{N, NE, E, SE, S, SW, W, NW}
	kingDir            = []Dir{N, NE, E, E2, SE, S, SW, W, W2, NW}
	queenDir           = []Dir{N, NE, E, SE, S, SW, W, NW}
	rookDir            = []Dir{N, E, S, W}
	bishopDir          = []Dir{NE, SE, SW, NW}
	knightDir          = []Dir{NNE, NEE, SEE, SSE, SSW, SWW, NWW, NNW}
	whitePawnDir       = []Dir{N, NN, NE, NW}
	whitePawnAttackDir = []Dir{NE, NW}
	blackPawnDir       = []Dir{S, SS, SE, SW}
	blackPawnAttackDir = []Dir{SE, SW}
)

// attackDir returns a slice of Dir in which a Piece attacks.
func (p Piece) attackDir() []Dir {
	switch p.Colorless() {
	case Queen, Rook, Bishop, Knight:
		return p.moveDir()
	case King:
		return kingAttackDir
	case Pawn:
		if p.Color() == White {
			return whitePawnAttackDir
		} else {
			return blackPawnAttackDir
		}
	}
	panic("direction not set up for piece " + p.String())
}

// moveDir returns a slice of Dir in which a Piece moves.
func (p Piece) moveDir() []Dir {
	switch p.Colorless() {
	case Queen:
		return queenDir
	case King:
		return kingDir
	case Rook:
		return rookDir
	case Bishop:
		return bishopDir
	case Pawn:
		if p.Color() == White {
			return whitePawnDir
		} else {
			return blackPawnDir
		}
	case Knight:
		return knightDir
	}
	panic("direction not set up for piece " + p.String())
}

// attackDistance returns the distance a piece can attack in a given direction.
func (p Piece) attackDistance(d Dir) int {
	switch p.Colorless() {
	case Knight, King, Pawn:
		return 1
	default:
		return 8
	}
}

// genMoves generates the set of moves for a piece at a coordinate.
func genMoves(p Piece, c Coord) (moves []Coord) {
	if p.isSlider() {
		return moves
	}
	for _, d := range p.moveDir() {
		pos := c.ApplyDir(d)
		if !pos.IsValid() {
			continue
		}
		moves = append(moves, pos)
	}
	return moves
}

// genAttacks returns a slice of Bit where a piece can attack.
func genAttacks(p Piece, c Coord) (attacks [64]Bit) {
	bit := c.Bit()
	for _, d := range p.attackDir() {
		for i, dis, pos := 0, p.attackDistance(d), c; i < dis; i++ {
			pos = pos.ApplyDir(d)
			if !pos.IsValid() {
				break
			}
			attacks[pos.Idx()] |= bit
		}
	}
	return attacks
}

func gen(w io.Writer) {
	// Make the moves/attacks LUT.
	movesForPiece := make([][][]Coord, Black*2)
	psuedosForPiece := make([][][64]Bit, Black*2)
	for _, c := range []Piece{Black, White} {
		for _, p := range []Piece{Pawn, Knight, King, Bishop, Rook, Queen} {
			p |= c
			psuedosForPiece[p] = make([][64]Bit, 64)
			for i := 0; i < 64; i++ {
				coord := CoordFromIdx(i)
				psuedosForPiece[p][i] = genAttacks(p, coord)
			}
			if !p.isSlider() {
				movesForPiece[p] = make([][]Coord, 64)
				for i := 0; i < 64; i++ {
					coord := CoordFromIdx(i)
					movesForPiece[p][i] = genMoves(p, coord)
				}
			}
		}
	}

	fmt.Fprintf(w, "var movesForPiece = [][][]Coord {\n")
	for i := range movesForPiece {
		fmt.Fprintf(w, "\t[][]Coord {\n")
		for j := range movesForPiece[i] {
			fmt.Fprintf(w, "\t\t[]Coord {")
			for k := range movesForPiece[i][j] {
				fmt.Fprintf(w, " %d,", movesForPiece[i][j][k].Idx())
			}
			fmt.Fprintf(w, "\t\t},\n")
		}
		fmt.Fprintf(w, "\t},\n")
	}
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var psuedosForPiece = [][]PsuedoMoves {\n")
	for i := range psuedosForPiece {
		fmt.Fprintf(w, "\t[]PsuedoMoves{\n")
		for j := range psuedosForPiece[i] {
			fmt.Fprintf(w, "\t\t[64]Bit{")
			for k := range psuedosForPiece[i][j] {
				fmt.Fprintf(w, " 0x%x,", psuedosForPiece[i][j][k].Uint64())
			}
			fmt.Fprintf(w, "\t\t},\n")
		}
		fmt.Fprintf(w, "\t},")
	}
	fmt.Fprintf(w, "}\n")
}

func main() {
	b := bytes.NewBuffer([]byte(header))
	gen(b)

	out, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	err = os.WriteFile("piece_tables.go", out, 0666)
	if err != nil {
		log.Fatal(err)
	}
}

var header = `package main
// Code generated by go generate. DO NOT EDIT.

// MovesForPiece returns a slice of slices of all the squares a piece could possibly move for
// a Piece at a given Coord.
func (p Piece) Moves(c Coord, occ Bit) []Coord {
	if p.isSlider() {
		if p.Colorless() == Bishop {
			return BishopLookup(c, occ)
		}
		return RookLookup(c, occ)
	}
	return movesForPiece[p][c.Idx()]
}

// Psuedos returns a slice of Bits where a piece could attack if it was at a current location.
func (p Piece) Psuedos(c Coord) *PsuedoMoves {
	return &psuedosForPiece[p][c.Idx()]
}
`
