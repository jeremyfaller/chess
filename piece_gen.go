// Generates Piece movement.

//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
)

var (
	kingAttackDir      = []Dir{N, NE, E, SE, S, SW, W, NW}
	kingDir            = []Dir{N, NE, E, E2, SE, S, SW, W, W2, NW}
	queenDir           = []Dir{N, NE, E, SE, S, SW, W, NW}
	rookDir            = []Dir{N, E, S, W}
	bishopDir          = []Dir{NE, SE, SW, NW}
	knightDir          = []Dir{NNE, NEE, SEE, SSE, SSW, SWW, NWW, NNW}
	whitePawnDir       = []Dir{N, NN, NE, NW}
	whitePawnAttackDir = []Dir{NE, NW}
	blackPawnDir       = []Dir{S, SS, SE, SW}
	blackPawnAttackDir = []Dir{SE, SW}
)

// AttackDir returns a slice of Dir in which a Piece attacks.
func (p Piece) AttackDir() []Dir {
	switch p.Colorless() {
	case Queen, Rook, Bishop, Knight:
		return p.MoveDir()
	case King:
		return kingAttackDir
	case Pawn:
		if p.Color() == White {
			return whitePawnAttackDir
		} else {
			return blackPawnAttackDir
		}
	}
	panic("direction not set up for piece " + p.String())
}

// MoveDir returns a slice of Dir in which a Piece moves.
func (p Piece) MoveDir() []Dir {
	switch p.Colorless() {
	case Queen:
		return queenDir
	case King:
		return kingDir
	case Rook:
		return rookDir
	case Bishop:
		return bishopDir
	case Pawn:
		if p.Color() == White {
			return whitePawnDir
		} else {
			return blackPawnDir
		}
	case Knight:
		return knightDir
	}
	panic("direction not set up for piece " + p.String())
}

// isSlider returns true if a piece is a sliding piece, ie it can move more
// than one space in a given direciton.
func (p Piece) isSlider() bool {
	switch p.Colorless() {
	case Bishop, Rook, Queen:
		return true
	default:
		return false
	}
}

// AttackDistance returns the distance a piece can attack in a given direction.
func (p Piece) AttackDistance(d Dir) int {
	switch p.Colorless() {
	case Knight, King, Pawn:
		return 1
	default:
		return 8
	}
}

// SlideDistance returns the distance a piece can slide.
func (p Piece) SlideDistance() int {
	if !p.isSlider() {
		return 1
	}
	return 8 // can slide upto the whole board.
}

// genMoves generates the set of moves for a piece at a coordinate.
func genMoves(p Piece, c Coord) (allMoves [][]Coord) {
	for _, d := range p.MoveDir() {
		pos := c
		moves := []Coord{}
		for i, dis := 0, p.SlideDistance(); i < dis; i++ {
			pos = pos.ApplyDir(d)
			if !pos.IsValid() {
				break
			}
			moves = append(moves, pos)
		}
		if len(moves) != 0 {
			allMoves = append(allMoves, moves)
		}
	}
	return allMoves
}

// genAttacks returns a slice of Bit where a piece can attack.
func genAttacks(p Piece, c Coord) (attacks [64]Bit) {
	bit := c.Bit()
	for _, d := range p.AttackDir() {
		for i, dis, pos := 0, p.AttackDistance(d), c; i < dis; i++ {
			pos = pos.ApplyDir(d)
			if !pos.IsValid() {
				break
			}
			attacks[pos.Idx()] |= bit
		}
	}
	return attacks
}

func gen(w io.Writer) {
	// Make the moves/attacks LUT.
	movesForPiece := make([][][][]Coord, Black*2)
	attacksForPiece := make([][][64]Bit, Black*2)
	for _, c := range []Piece{Black, White} {
		for _, p := range []Piece{King, Queen, Rook, Bishop, Knight, Pawn} {
			p |= c
			movesForPiece[p] = make([][][]Coord, 64)
			attacksForPiece[p] = make([][64]Bit, 64)
			for i := 0; i < 64; i++ {
				coord := CoordFromIdx(i)
				movesForPiece[p][i] = genMoves(p, coord)
				attacksForPiece[p][i] = genAttacks(p, coord)
			}
		}
	}

	fmt.Fprintf(w, "var movesForPiece = [][][][]Coord {\n")
	for i := range movesForPiece {
		fmt.Fprintf(w, "\t[][][]Coord {\n")
		for j := range movesForPiece[i] {
			fmt.Fprintf(w, "\t\t[][]Coord {\n")
			for k := range movesForPiece[i][j] {
				fmt.Fprintf(w, "\t\t\t[]Coord {")
				for m := range movesForPiece[i][j][k] {
					fmt.Fprintf(w, " %d,", movesForPiece[i][j][k][m].Idx())
				}
				fmt.Fprintf(w, "},")
			}
			fmt.Fprintf(w, "\t\t},\n")
		}
		fmt.Fprintf(w, "\t},\n")
	}
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var attacksForPiece = [][]PsuedoMoves {\n")
	for i := range attacksForPiece {
		fmt.Fprintf(w, "\t[]PsuedoMoves{\n")
		for j := range attacksForPiece[i] {
			fmt.Fprintf(w, "\t\t[64]Bit{")
			for k := range attacksForPiece[i][j] {
				fmt.Fprintf(w, " 0x%x,", attacksForPiece[i][j][k].Uint64())
			}
			fmt.Fprintf(w, "\t\t},\n")
		}
		fmt.Fprintf(w, "\t},")
	}
	fmt.Fprintf(w, "}\n")
}

func main() {
	b := bytes.NewBuffer([]byte(header))
	gen(b)

	out, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	err = os.WriteFile("piece_tables.go", out, 0666)
	if err != nil {
		log.Fatal(err)
	}
}

var header = `package main
// Code generated by go generate. DO NOT EDIT.

// MovesForPiece returns a slice of slices of all the squares a piece could possibly move for
// a Piece at a given Coord.
func (p Piece) Moves(c Coord) [][]Coord {
	return movesForPiece[p][c.Idx()]
}

// AttacksForPiece returns a slice of Bits where a piece could attack if it was at a current location.
func (p Piece) Attacks(c Coord) *PsuedoMoves {
	return &attacksForPiece[p][c.Idx()]
}
`
