//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
)

var header = `package main
// Code generated by go generate. DO NOT EDIT.

// DirBetween returns a Dir, given two coords.
//
// Returns InvalidDir if there's not mapping.
func DirBetween(from, to Coord) Dir {
	return dirs[from.Idx()][to.Idx()]
}
`

func gen(w io.Writer) {
	var dirs [64][64]Dir

	for i := 0; i < 64; i++ {
		c := CoordFromIdx(i)
		for _, d := range []Dir{N, NE, E, SE, S, SW, W, NW} {
			last := c
			for {
				last = last.ApplyDir(d)
				if !last.IsValid() {
					break
				}
				dirs[i][last.Idx()] = d
			}
		}
		for _, d := range []Dir{NNE, NEE, SEE, SSE, SSW, SWW, NWW, NNW} {
			if last := c.ApplyDir(d); last.IsValid() {
				dirs[i][last.Idx()] = d
			}
		}
	}

	fmt.Fprintf(w, `
// dirs is an array of LUTs, one for each square. For each of the squares, it
// maps a given coordinate to the direciton it takes to get there. Note, that
// it only returns valid standard directions, not special directions for pawns,
// and castling.
`)
	fmt.Fprintf(w, "var dirs = [64][64]Dir {\n")
	for i := range dirs {
		fmt.Fprintf(w, "\t[64]Dir{")
		for j := range dirs[i] {
			fmt.Fprintf(w, "Dir(%d),", dirs[i][j])
		}
		fmt.Fprintf(w, "},\n")
	}
	fmt.Fprintf(w, "}\n")
}

func main() {
	flag.Parse()
	b := bytes.NewBuffer([]byte(header))
	gen(b)

	out, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	err = os.WriteFile("coord_tables.go", out, 0666)
	if err != nil {
		log.Fatal(err)
	}
}
